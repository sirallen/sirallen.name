---
title: 'Data Viz: Population Growth Trajectories of U.S. Metropolitan Areas'
author: Allen Sirolly
date: '2017-09-29'
slug: population-growth-trajectories-metropolitan-areas
categories: []
tags: []
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE)
```

Earlier this year I wanted to learn more about the population growth rates of cities in the United States. I had read that cities were burgeoning again after a period of stagnation in the early- and mid-2000s, and I had seen evidence in the form of gentrifying neighborhoods in Philadelphia and scores of construction cranes skirting Washington. But what I found was mostly limited to tables and charts like [this one](https://www.census.gov/content/dam/Census/library/visualizations/2017/comm/cb17-81-grahic-citypopestimate.pdf) which simply present rankings over fixed time periods. (And I've never even heard of those places.) Unsatisfied, I went to Census.gov to explore the data myself. This necessitated a non-trivial amount of data munging---maybe the reason for my unfruitful search---so I've decided to share my process below. The end result is [this nice visualization](https://www.dropbox.com/s/zw7fmq20bf38l3p/CityGrowthByRegion_largeSmooth2.pdf?raw=1) which I hope to make interactive later.

The unit of analysis is a Metropolitan Statistical Area (MSA), which comprises an urban center together with a set of outlying counties with close economic ties; there are roughly 380 of them. The Census publishes _intercensal_ population estimates on an annual basis, with necessary revisions back to the most recent census year. MSA-level estimates are only available since 2010, so to extend the data to previous years one needs to aggregate county-level estimates. The data can be retrieved via calls to an API.^[See [here](https://www.census.gov/content/dam/Census/data/developers/api-user-guide/api-guide.pdf) for the API documentation. The data may also be downloaded from [Metropolitan and Micropolitan Statistical Area Datasets](https://www.census.gov/data/datasets/2016/demo/popest/total-metro-and-micro-statistical-areas.html) and [County Intercensal Datasets](https://www.census.gov/data/datasets/time-series/demo/popest/intercensal-2000-2010-counties.html).]

The following code is available as a plain R script [here](https://www.dropbox.com/s/slvg4nno6hwidtk/_Census-msa-growth.R?raw=1).

```{r, message=FALSE}
library(httr)
library(purrr)
library(data.table)
library(ggplot2)
library(ggrepel)
library(grid)
library(gridExtra)
```
```{r, eval=FALSE}
msa10.16 =
  GET(
    url = paste0('https://api.census.gov/data/2016/pep/population?',
                 'get=POP,DATE,DATE_DESC,GEONAME',
                 '&for=metropolitan+statistical+area/micropolitan+statistical+area:*')
  ) %>%
  content() %>%
  map(setNames, unlist(.[[1]])) %>%
  keep(function(x) grepl('Metro Area', x$GEONAME)) %>%
  keep(function(x) grepl('estimate$', x$DATE_DESC)) %>%
  rbindlist() %>%
  setnames('metropolitan statistical area/micropolitan statistical area', 'MSA') %>%
  setnames('GEONAME', 'MSA_NAME')

msa10.16[, `:=`(
  DATE = NULL,
  YEAR = stringr::str_extract(DATE_DESC, '\\d{4}'),
  DATE_DESC = NULL,
  MSA_NAME = gsub(' Metro Area', '', MSA_NAME))][
    # convert columns char --> int
    , c('POP','YEAR','MSA'):= lapply(.SD, as.integer),
    .SDcols=c('POP','YEAR','MSA')]

county00.09 =
  GET(
    url = paste0('https://api.census.gov/data/2000/pep/int_population?',
                 'get=POP,DATE,DATE_DESC,GEONAME',
                 '&for=county:*')
  ) %>%
  content() %>%
  map(setNames, unlist(.[[1]])) %>%
  keep(function(x) grepl('estimate$', x$DATE_DESC)) %>%
  rbindlist()

county00.09[, `:=`(
  DATE = NULL,
  YEAR = stringr::str_extract(DATE_DESC, '\\d{4}'),
  DATE_DESC = NULL)][
    # convert columns char --> int
    , c('POP','YEAR'):= lapply(.SD, as.integer),
    .SDcols=c('POP','YEAR')]
```

```{r echo=FALSE}
#save(county00.09, file='county.RData')
#save(msa10.16, file='msa.RData')
load('county.RData')
load('msa.RData')
```
The correspondence between counties and MSAs prior to 2010 is established in a set of [historical delineation files](https://www.census.gov/geographies/reference-files/time-series/demo/metro-micro/historical-delineation-files.html). There is a delineation file for each year from 2003-2009 (updated in November or December) and at less frequent intervals before 2003. The implication is that MSA definitions can change over time, perhaps as urban centers see their spheres of influence expand or contract, or as micropolitan statistical areas grow large enough to merit classification as metropolitan areas.^[Micropolitan and metropolitan statistical areas are collectively called _core-based statistical areas_ (CBSAs).]

These files aren't in the API, so we'll need to download and parse them separately. (This processing step is kind of tangential to the task at hand, so I've hidden the function `parse_delin_file` from view; it's in the raw R file I linked to above.) Let's start from 2003, which will yield us 14 years of population estimates. This should be enough to make a compelling graphic.^[Fortunately, the files seem to share a common format so it shouldn't be too difficult to prepend earlier data.]
```{r, echo=FALSE}
parse_delin_file = function(url) {
  da =
    read.fwf(
      url(url), skip=11, widths=c(5,3,5,3,2,3,3,80), stringsAsFactors=FALSE
    ) %>%
    dplyr::select(-c(2,3,4,7)) %>%
    dplyr::filter(grepl('\\d{5}', V1)) %>%
    setDT() %>%
    setnames(c('MSA','state','county','Name'))
  
  da[, names(da):= lapply(.SD, function(z) {z[grepl('^ *$',z)] = NA; z}), .SDcols=names(da)]
  da[, Name:= stringr::str_trim(Name, 'right')]
  da[, MSA_NAME:=
       zoo::na.locf(
         stringr::str_extract(
           Name, '.*(?= Metropolitan Statistical Area)'))]
  da[, MSA:= as.integer(MSA)]
  setcolorder(da, c(1:3, 5, 4))
  
  da
}
```

```{r}
delin_files = paste0(
  'https://www2.census.gov/programs-surveys/metro-micro/geographies/reference-files/',
  2003:2009, '/historical-delineation-files/', c('0312msa', rep('list4', 6)), '.txt')

msa_delin = setNames(lapply(delin_files, parse_delin_file), 2003:2009)

print(msa_delin$`2009`)
```

The next step is to merge each delineation file with the county population estimates for the corresponding year, using the state and county FIPS codes. This can be done with the Map function. Then we can simply sum the population estimates by year/MSA and bind the 2003-2009 and 2010-2016 data sets together.

Note: Some of the 5-digit MSA codes do not comport across (or even within) data sets, even though their labels suggest that they represent the same MSA. For each of these cases, I recode the MSA to match the most recent version.
```{r}
msa03.09 = Map(function(delin, year) delin[county00.09[YEAR==year],
                                           on=.(state, county), nomatch=0],
               msa_delin, as.list(2003:2009))

msa03.09 = lapply(msa03.09, function(d) d[, .(POP = sum(POP)), by='MSA'])

msa03.16 = rbindlist(
  list(
    rbindlist(
      msa03.09, idcol='YEAR'
    )[, YEAR:= as.integer(YEAR)],
    msa10.16
  ),
  fill=TRUE
)

# Steubenville-Weirton, OH-WV --> Weirton-Steubenville, WV-OH
msa03.16[MSA==44600, MSA:= 48260]
# Vero Beach, FL --> Sebastian-Vero Beach, FL
msa03.16[MSA==46940, MSA:= 42680]
# Santa Barbara-Santa Maria-Goleta, CA --> Santa Maria-Santa Barbara, CA
msa03.16[MSA==42060, MSA:= 42200]
# Los Angeles-Long Beach-Santa Ana, CA --> Los Angeles-Long Beach-Anaheim, CA
msa03.16[MSA==31100, MSA:= 31080]
# Lafayette, IN --> Lafayette-West Lafayette, IN
msa03.16[MSA==29140, MSA:= 29200]
# Honolulu, HI --> Urban Honolulu, HI
msa03.16[MSA==26180, MSA:= 46520]
# Bloomington-Normal, IL --> Bloomington, IL
msa03.16[MSA==14060, MSA:= 14010]
# Sarasota-Bradenton-Venice, FL --> North Port-Sarasota-Bradenton, FL
msa03.16[MSA==42260, MSA:= 35840]
# Bradenton-Sarasota-Venice, FL --> North Port-Sarasota-Bradenton, FL
msa03.16[MSA==14600, MSA:= 35840]
# Fort Walton Beach-Crestview-Destin, FL --> Crestview-Fort Walton Beach-Destin, FL
msa03.16[MSA==23020, MSA:= 18880]

setkey(msa03.16, MSA, YEAR)

msa03.16[, MSA_NAME:= zoo::na.locf(MSA_NAME, fromLast=TRUE), by='MSA']

# Restrict to MSAs with data over entire sample period (2003 - 2016)
msa03.16 = msa03.16[msa03.16[, .I[.N==14], by='MSA']$V1]
```

Patching these two series together results in several sharp discontinuities in 2009-2010 (maybe due to some MSAs being redefined after the 2010 Census). As we're ultimately interest in growth rates as opposed to levels, these discontinuities can be "corrected" by adjusting the population estimates. A reasonable adjustment is to assume the growth rate from 2009-2010 to be the average of growth rates from 2008-2009 and 2010-2011. If $X_i$ is the population in year $i$ and $g_{i,j} = X_j / X_i - 1$ the population growth rate from year $i$ to year $j$, define the adjusted estimates
$$
\tilde{X}_i = X_{2009} (1 + g_{2010, i}) \sqrt{(1 + g_{2008, 2009})(1 + g_{2010, 2011})} \\[1.2em]
= X_i \frac{X_{2009}}{X_{2010}} \sqrt{\frac{X_{2009}}{X_{2008}} \cdot \frac{X_{2011}}{X_{2010}}}
$$
for $i \geq 2010$ and $\tilde{X}_i = X_i$ for $i < 2010$. Doing it this way essentially joins the segments $X_{2003:2009}$ and $X_{2010:2016}$ while preserving growth rates within each. But bear in mind that some MSA definitions may not be consistent over the entire sample period.

Sanity check that it works:
```{r}
msa03.16[, POP_Adj:= ifelse(YEAR < 2010, POP,
  POP/POP[YEAR==2010] * POP[YEAR==2009] * 
    sqrt(POP[YEAR==2009]/POP[YEAR==2008] * POP[YEAR==2011]/POP[YEAR==2010])),
  by='MSA']

with(msa03.16[MSA==18880], {
  matplot(YEAR, cbind(POP, POP_Adj)/1000, type='l', las=1,
          ylab='Population (thousands)', main=MSA_NAME[1])
  legend('topleft', c('POP', 'POP_Adj'), lty=1:2, col=c('black','red'),
         inset=.01)
})
```

Instead of calculating growth rates directly, let's construct a population index, or _trajectory_, with base year 2003, $\hat{X}_i = 100 \times \tilde{X}_i / X_{2003}$. Plotting the trajectories will give a nice visual representation while permitting approximate comparisons of growth for different MSAs, or for the same MSA at different points in time. Let's also compute the average trajectory of all MSAs in our sample to provide a baseline comparison. (Note that summing `POP` by year gives us a population-weighted average, as opposed to equal-weighted.)
```{r}
# Calculate population index (=100 in base year 2003)
msa03.16[, POP_Idx:= 100 * POP_Adj / POP_Adj[1], by='MSA']

msa.Avg =
  msa03.16[, .(MSA_NAME='MSA.Average', MSA.short='MSA.Average', POP_Adj=sum(POP_Adj)),
           keyby='YEAR'][
             , POP_Idx:= 100 * POP_Adj / POP_Adj[1]]
```

The following code chunk shortens the names of MSAs (e.g., "New York-Newark-Jersey City, NY-NJ-PA" becomes "New York, NY") and assigns them to one of the four major Census regions. We can then construct plot labels by appending an integer pair representing an MSA's population rank within its region as well as overall.
```{r}
# Plot data - first restrict to 'large' MSAs
plotData = msa03.16[msa03.16[, .I[max(POP) > 8e5], by='MSA']$V1]

plotData = rbindlist(list(black=plotData, red=msa.Avg), fill=TRUE, idcol='line_color')

# short names, regions
plotData[, MSA.short:= gsub('([^-/]*).*(, [A-Z]{2}).*', '\\1\\2', MSA_NAME)]
plotData[grepl('(ME|NH|VT|MA|RI|CT|NY|PA|NJ)$', MSA.short), Region:= 'Northeast']
plotData[grepl('(OH|IN|IA|MI|WI|MN|ND|SD|NE|KS|IL|MO)$', MSA.short), Region:= 'Midwest']
plotData[grepl('(DE|MD|DC|VA|WV|NC|SC|GA|FL|KY|TN|AL|MS|AR|LA|OK|TX)$', MSA.short), Region:= 'South']
plotData[grepl('(NM|AZ|CO|WY|MT|ID|UT|NV|WA|OR|CA|AK|HI)$', MSA.short), Region:= 'West']

plotData[MSA.short=='Urban Honolulu, HI', MSA.short:= 'Honolulu, HI']

# Remove Puerto Rico
plotData = plotData[!grepl('PR$', MSA.short)]

# Population size ranks
plotData[MSA_NAME!='MSA.Average', sizeRank:= frank(-POP_Adj), by='YEAR']
plotData[MSA_NAME!='MSA.Average', sizeRank_region:= frank(-POP_Adj), by=.(YEAR, Region)]
plotData[MSA_NAME!='MSA.Average', sizeRank_label:= paste0(' (', sizeRank_region, ',', sizeRank, ')')]
plotData[, label:= ifelse(MSA_NAME=='MSA.Average', MSA_NAME, paste0(MSA.short, sizeRank_label))]
```

Finally, our plot will be more visually appealing with smooth curves that pass through a common point $(2003, 100)$. This can be achieved by fitting a polynomial regression (sans intercept)
$$
popidx_j - 100 = \text{poly}(year_j - 2003, 5) \; \boldsymbol{\beta}_j + \boldsymbol{\varepsilon}_j
$$
for each MSA $j$ and computing fitted values at sufficiently high resolution. I chose $k = 5$ as the polynomial degree because it produces a good visual result without overfitting or underfitting the sample points. (Note that I exclude New Orleans, LA due to a large population shock (-25%) in the aftermath of Hurricane Katrina in 2005. A piecewise smooth might be more appropriate for this exceptional case.)

```{r}
xgrid = seq(2003, 2016, .1)

polyfit = plotData[MSA.short!='New Orleans, LA', .(
  YEAR = xgrid,
  POP_Idx = predict(
    lm(I(POP_Idx - 100) ~ 0 + poly(YEAR - 2003, 5, raw=TRUE)),
    newdata=data.frame(YEAR=xgrid)) + 100
  ),
  by=.(Region, MSA.short, line_color)]

plotData = plotData[, .(YEAR=as.double(YEAR), MSA.short, label)][
  polyfit, on=.(YEAR, MSA.short)]
```

Now we're ready to plot the data! We can assign a `ggplot` object to a variable for each Census region and pass these objects to `gridExtra::grid.arrange` to organize into a 2-by-2 panel. (Perhaps this could just as well be accomplished with `ggplot2::facet_wrap`.) Note that the use of the `direction` argument in `ggrepel::geom_text_repel` currently requires the development version of the package, which can be installed from GitHub.
```{r, fig.width=12, fig.height=15}
for (region in c('Northeast','Midwest','South','West')) {
  assign(paste0('p.',region),
         ggplot(plotData[MSA.short!='New Orleans, LA'],
                aes(x=YEAR, y=POP_Idx, group=MSA.short, color=line_color)) +
           scale_x_continuous(breaks=seq(2003,2016,2), limits=c(2003,2017.5)) +
           scale_y_continuous(breaks=seq(80,150,10)) +
           geom_line(data = plotData[Region==region], size=.25) +
           geom_line(data = plotData[MSA.short=='MSA.Average']) +
           geom_text_repel(
             data = plotData[(Region==region | is.na(Region)) & YEAR==max(YEAR)],
             aes(label = label), size=1.5, box.padding=0,
             direction='y', xlim=c(2016.1, NA)) +
           scale_color_manual(values = c(black='black', red='red')) +
           labs(title = bquote(italic(.(region))),
                x='', y='Population Index (Base Year = 2003)') +
           theme_bw() +
           theme(legend.position='none', plot.margin=margin(.5, 1.5, .1, .5, 'lines'),
                 panel.border=element_rect(color=NA))
  )
}; rm(region)

grid.arrange(
  top = textGrob(
    label = expression(bolditalic(
      'Population Growth Trajectories of Large Metropolitan Areas, 2003-2016')),
    gp=gpar(cex=1.6)
  ),
  bottom = textGrob(
    label = expression(italic(
      'Data: Census.gov/programs-surveys/popest.html')),
    x=unit(.95, 'npc'), just='right', gp=gpar(cex=1.2)
  ),
  p.Northeast, p.Midwest, p.South, p.West, ncol=2
)
```

(You can right-click and "open in new tab" to magnify the image.)

It's nice to be able to see the full population trajectories---for example, we can see that Boston experienced negative growth in the years following 2003 but reversed course to become the Northeast's fastest-growing metropolitan area over the past decade. One of the immediate takeaways, however, is that the most impressive growth is concentrated in the South and the West, led by the likes of Austin, Raleigh, and Las Vegas. (I'm reminded of this [article](https://www.washingtonpost.com/realestate/fast-growing-technology-sector-is-fueling-a-housing-boom-in-cities-across-america/2017/01/26/5c72c276-a5d8-11e6-8042-f4d111c862d1_story.html
).)

Finally, a note of caution regarding interpretation. The choice of 2003 as the base year is arbitrary, so take the ordering of the labels with a grain of salt. Moreover, today's fastest-growing MSAs are not necessarily those highest on the y-scale, but rather those with the largest slopes at $x = 2016$ (roughly). There are mild distortions in these slopes due to [Runge's phenomenon](https://en.wikipedia.org/wiki/Runge%27s_phenomenon), and it would be ill-advised to try to extrapolate more than a year or two into the future.^[Maybe the smoothing step could be improved by running a penalized regression with penalty proportional to the deviation in slopes, i.e., something along the lines of
$$
\min_\beta \left\{ (y - X\beta)^\intercal (y - X\beta) + \gamma ||(X \beta)'(2015) - (1 + g_{2015, 2016})|| \right\}
$$
] (It's doubtful that Pittsburgh, PA will see its population nosedive to zero in five years.)

**Addendum.** The _Wall Street Journal_ produced a similar [graphic](https://www.dropbox.com/s/7quwm2zzh56j272/NA-CO335A_SIOUX_16U_20170315160308.jpg?raw=1) for an excellent [article](https://www.wsj.com/articles/as-many-midwest-cities-slump-sioux-falls-soars-1489743009) about Sioux Falls, SD earlier this year. (I like my version better :3) Oddly, I wasn't able to locate any MSA population data from the Bureau of Economic Analysis, which is listed as the data source. I did, however, find BEA data on [GDP by MSA](https://www.bea.gov/newsreleases/regional/gdp_metro/gdp_metro_newsrelease.htm) which looks interesting.


